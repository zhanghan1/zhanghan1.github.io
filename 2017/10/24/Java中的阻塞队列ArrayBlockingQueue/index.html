<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="淡定、从容"><title>Java中的阻塞队列ArrayBlockingQueue | 基础架构研究</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的阻塞队列ArrayBlockingQueue</h1><a id="logo" href="/.">基础架构研究</a><p class="description">hello,world</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java中的阻塞队列ArrayBlockingQueue</h1><div class="post-meta">Oct 24, 2017<span> | </span><span class="category"><a href="/categories/Java并发/">Java并发</a></span></div><div class="post-content"><h1 id="1-ArrayBlockingQueue介绍"><a href="#1-ArrayBlockingQueue介绍" class="headerlink" title="1.ArrayBlockingQueue介绍"></a>1.ArrayBlockingQueue介绍</h1><h2 id="1-1BlockingQueue接口"><a href="#1-1BlockingQueue接口" class="headerlink" title="1.1BlockingQueue接口"></a>1.1BlockingQueue接口</h2><blockquote>
<p>Interface BlockingQueue<e><br>支持阻塞等待的队列：当取出元素的时候，若队列为空，wait直到队列非空；当存储元素的时候，若队列满，wait直到队列有空闲。<br>对于BlockingQueue，当执行操作的条件不满足时，有四种形式。</e></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Special value</th>
<th>Blocks</th>
<th>Times out</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e)<br>（若队列未满，添加，返回true；<br>若队列满，抛出IllegalStateException）</td>
<td>offer(e)<br>（若队列未满，添加，返回true；<br>若队列满，返回false）</td>
<td>put(e)<br>（若队列未满，添加，无返回值；<br>若队列满，wait直到队列有空闲）</td>
<td>offer(e, time, unit)<br>（若队列未满，添加，返回true；<br>若队列满，wait指定时间后队列还是满，返回false）</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()（若队列非空，移除，返回true；若队列空，返回false）</td>
<td>poll()（若队列非空，移除；若队列空，返回null）</td>
<td>take()（若队列非空，移除；若队列空，wait直到队列非空）</td>
<td>poll(time, unit)（若队列非空，移除；若队列空，wait指定时间后队列还是空，返回null）</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td>not applicable</td>
<td>not applicable</td>
</tr>
</tbody>
</table>
<p>使用样例——典型的(多）生产者、（多）消费者模型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生产者线程</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;<span class="comment">//阻塞队列</span></div><div class="line">   Producer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; queue.put(produce()); &#125;<span class="comment">//生产，并入队</span></div><div class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">   &#125;</div><div class="line">   <span class="function">Object <span class="title">produce</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line"> &#125;</div><div class="line"><span class="comment">//消费者线程</span></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;<span class="comment">//阻塞队列</span></div><div class="line">   Consumer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; consume(queue.take()); &#125;<span class="comment">//出队，消费</span></div><div class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object x)</span> </span>&#123; ... &#125;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Setup</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">     BlockingQueue q = <span class="keyword">new</span> SomeQueueImplementation();</div><div class="line">    <span class="comment">//启动1个生产者线程，2个消费者线程</span></div><div class="line">     Producer p = <span class="keyword">new</span> Producer(q);</div><div class="line">     Consumer c1 = <span class="keyword">new</span> Consumer(q);</div><div class="line">     Consumer c2 = <span class="keyword">new</span> Consumer(q);</div><div class="line">     <span class="keyword">new</span> Thread(p).start();</div><div class="line">     <span class="keyword">new</span> Thread(c1).start();</div><div class="line">     <span class="keyword">new</span> Thread(c2).start();</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="1-2ArrayBlockingQueue"><a href="#1-2ArrayBlockingQueue" class="headerlink" title="1.2ArrayBlockingQueue"></a>1.2ArrayBlockingQueue</h2><p>ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。<br><br>1.数组实现：使用数组实现循环队列。<br><br>2.线程安全：使用了ReentrantLock来保证线程安全。<br><br>3.有界：可存储的元素的个数固定的。因内部为数组实现，一旦创建完成，数组的长度不能再改变。<br><br>4.阻塞队列：先进先出。当取出元素的时候，若队列为空，wait直到队列非空；当存储元素的时候，若队列满，wait直到队列有空闲。</p>
<h1 id="2-ArrayBlockingQueue源码分析"><a href="#2-ArrayBlockingQueue源码分析" class="headerlink" title="2.ArrayBlockingQueue源码分析"></a>2.ArrayBlockingQueue源码分析</h1><h2 id="2-1创建"><a href="#2-1创建" class="headerlink" title="2.1创建"></a>2.1创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];<span class="comment">//数组存储元素</span></div><div class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);<span class="comment">//锁保证线程安全</span></div><div class="line">    notEmpty = lock.newCondition();</div><div class="line">    notFull =  lock.newCondition();</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">## 2.2生产者消费者模型</div><div class="line">生产者-消费者模型</div><div class="line">### 2.2.1生产者生产元素——put方法元素进队</div><div class="line">put方法&lt;br&gt;</div><div class="line">如何实现【生产者】和【消费者】线程之间的同步&lt;br&gt;</div><div class="line"><span class="number">1</span>.若队列满，调用notFull.await()方法，使当前【生产者】线程阻塞等待&lt;br&gt;</div><div class="line"><span class="number">2</span>.元素进队后，调用notEmpty.signal()方法，唤醒阻塞的【消费者】线程</div><div class="line"></div><div class="line">``` java</div><div class="line"><span class="comment">//插入指定的element到队列的尾部</span></div><div class="line"><span class="comment">//若队列满，当前线程等待，直到队列有空闲</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    <span class="comment">//获得锁</span></div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//若队列满，当前线程等待，直到队列有空闲</span></div><div class="line">        <span class="keyword">while</span> (count == items.length)</div><div class="line">            notFull.await();</div><div class="line">        <span class="comment">//队列有空闲，元素进队</span></div><div class="line">        enqueue(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[putIndex] == null;</span></div><div class="line">    <span class="comment">//元素进队</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;</div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;</div><div class="line">    <span class="comment">//唤醒阻塞在notEmepty上的线程</span></div><div class="line">    notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-2消费者消费元素——take方法元素出队"><a href="#2-2-2消费者消费元素——take方法元素出队" class="headerlink" title="2.2.2消费者消费元素——take方法元素出队"></a>2.2.2消费者消费元素——take方法元素出队</h3><p>take方法<br><br>如何实现【生产者】和【消费者】线程同步<br><br>1.若队列为空，调用notEmpty.await()方法，使当前【消费者】线程阻塞等待<br><br>2.元素进队后，调用notFull.signal()方法，唤醒阻塞的【生产者】线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回队列头部的元素</span></div><div class="line"><span class="comment">//若队列为空，等待，直到队列非空</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    <span class="comment">//获得锁</span></div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//若队列为空，等待，直到队列非空</span></div><div class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">            notEmpty.await();</div><div class="line">        <span class="comment">//队列非空，返回队头元素</span></div><div class="line">        <span class="keyword">return</span> dequeue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[takeIndex] != null;</span></div><div class="line">    <span class="comment">//返回队头元素</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    E x = (E) items[takeIndex];</div><div class="line">    items[takeIndex] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</div><div class="line">        takeIndex = <span class="number">0</span>;</div><div class="line">    count--;</div><div class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line">        itrs.elementDequeued();</div><div class="line">    <span class="comment">//唤醒阻塞在notFull上的线程</span></div><div class="line">    notFull.signal();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/10/07/Log4j2中RollingFileAppender详解/" class="next">Log4j2中RollingFileAppender详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://inf-research.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发/">Java并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/Java中的阻塞队列ArrayBlockingQueue/">Java中的阻塞队列ArrayBlockingQueue</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/07/Log4j2中RollingFileAppender详解/">Log4j2中RollingFileAppender详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/06/MySQL中的replace语句/">MySQL中的replace语句</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.baidu.com/" title="baidu" target="_blank">baidu</a><ul></ul><a href="https://www.haomwei.com/" title="屠城" target="_blank">屠城</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">基础架构研究.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>